<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (1.8.0_241) on Fri Sep 25 11:18:19 CEST 2020 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>StreamingPathFilter</title>
<meta name="date" content="2020-09-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="StreamingPathFilter";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/StreamingPathFilter.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../net/datenwerke/eximport/nuxlets/StreamingPathFilterException.html" title="class in net.datenwerke.eximport.nuxlets"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?net/datenwerke/eximport/nuxlets/StreamingPathFilter.html" target="_top">Frames</a></li>
<li><a href="StreamingPathFilter.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">net.datenwerke.eximport.nuxlets</div>
<h2 title="Class StreamingPathFilter" class="title">Class StreamingPathFilter</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>net.datenwerke.eximport.nuxlets.StreamingPathFilter</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">StreamingPathFilter</span>
extends java.lang.Object</pre>
<div class="block">Streaming path filter node factory for continuous queries and/or transformations 
 over very large or infinitely long XML input.
 <p>
 <h4>Background</h4>
 
 The W3C XQuery and XPath languages often require the <i>entire</i> input
 document to be buffered in memory for a query to be executed in its full
 generality [<a target="_blank"
 href="http://www.research.ibm.com/xj/pubs/icde.pdf">Background Paper</a>,
 <a target="_blank"
 href="http://www-dbs.informatik.uni-heidelberg.de/publications/">More Papers</a>]. 
 In other words, XQuery and XPath are hard to stream over very large or
 infinitely long XML inputs without violating some aspects of the W3C
 specifications. However, subsets of these languages (or simplified cousins)
 can easily support streaming.
 <p>
 In fact, most use cases dealing with very large XML input documents do not
 require the full <i>forward and backward</i> navigational capabilities of
 XQuery and XPath <i>across independent element subtrees</i>. Rather those
 use cases are record oriented, treating element subtrees (i.e. records)
 independently, individually selecting/projecting/transforming record after
 record, one record at a time. For example, consider an XML document with one
 million records, each describing a published book, music album or web server
 log entry. A query to find the titles of books that have more than three
 authors looks at each record individually, hence can easily be streamed. 
 Another use case is splitting a document into several sub-documents based on 
 the content of each record.
 <p>
 More interestingly, consider a P2P XML content messaging router, network
 transducer, transcoder, proxy or message queue that continuously 
 filters, transforms, routes and dispatches messages from infinitely long 
 streams, with the behaviour defined by deeply inspecting rules (i.e. queries) 
 based on content, network parameters or other metadata.
 This class provides a convenient solution for such common use cases operating
 on very large or infinitely long XML input. The solution uses a strongly
 simplified location path language (which is modelled after XPath but <i>not</i> 
 XPath compliant), in combination with a <code>nu.xom.NodeFactory</code> and
 an optional <code>XQuery</code>. The solution is not necessarily faster than
 building the full document tree, but it consumes much less main memory.
 <p>
 <h4>Here is how it works</h4>
 
 You specify a simple "location path" such as <code>/books/book</code> or
 <code>/weblogs/_2004/_05/entry</code>. The path may contain wildcards and
 indicates which elements should be retained. All elements not matching the
 path will be thrown away during parsing. Each retained element is fully
 build (including its ancestors and descendants) and then made available to
 the application via a callback to an application-provided
 <a href="../../../../net/datenwerke/eximport/nuxlets/StreamingTransform.html" title="interface in net.datenwerke.eximport.nuxlets"><code>StreamingTransform</code></a> object.
 <p>
 The <code>StreamingTransform</code> can operate on the fully build element (subtree)
 in arbitrary ways. For example, it can simply print the element to screen or
 disk and then forget about it. Or it can add the element (subtree) to the
 document currently build by the <code>nu.xom.Builder</code>. In addition, a
 transform can check conditions such as <i>has book more than three authors?
 </i> A transform can also replace the element with a different element or a
 list of arbitrary generated nodes. For example, if a book has more than three
 authors, just the book title with a <code>authorCount</code> attribute 
 can be added to the document, instead of the entire book element subtree.
 <p>
 Typically, simple <code>StreamingTransforms</code> are formulated in custom
 Java code, whereas complex ones are formulated as an <code>XQuery</code>.
 <p>
 <h4>Streaming Location Path Syntax</h4>
 
 <pre>
 locationPath := {'/'step}...
 step := [prefix':']localName  
 prefix := '*' | '' | XMLNamespacePrefix 
 localName := '*' | XMLLocalName
 </pre>
 
 A location path consists of zero or more location steps separated by "/".
 A step consists of an optional XML namespace prefix followed by a local name.
 The wildcard symbol '*' means: <i>Match anything</i>. 
 An empty prefix ('') means: <i>Match if in no namespace (i.e. null namespace)</i>. 
 
 <p>
 Example legal location steps are:
 <pre>
 book       (Match elements named "book" in no namespace) 
 :book      (Match elements named "book" in no namespace)
 bib:book   (Match elements named "book" in "bib" namespace)
 bib:*      (Match elements with any name in "bib" namespace)
 *:book     (Match elements named "book" in any namespace, including no namespace)
 *:*        (Match elements with any name in any namespace, including no namespace)
 :*         (Match elements with any name in no namespace)
 </pre>
 
 Obviously, the location path language is quite simplistic, supporting the "child" axis only.
 For example, axes such as descendant ("//"), ancestors, following, preceding, as well as
 predicates and other XPath features are not supported. Typically, this does not matter 
 though, because a full XQuery can still be used on each element (subtree) matching the 
 location path, as follows: 
 
 <h4>Example Usage</h4>
 
 The following is complete and efficient code for parsing and iterating through millions of 
 "person" records in a database-like XML document, printing all residents of "San Francisco", 
 while never allocating more memory than needed to hold one person element:
 <pre>
 StreamingTransform myTransform = new StreamingTransform() {
     public Nodes transform(Element person) {
         Nodes results = XQueryUtil.xquery(person, "name[../address/city = 'San Francisco']");
         if (results.size() > 0) {
             System.out.println("name = " + results.get(0).getValue());
         }
         return new Nodes(); // mark current element as subject to garbage collection
     }
 };
 
 // parse document with a filtering Builder
 Builder builder = new Builder(new StreamingPathFilter("/persons/person", null)
     .createNodeFactory(null, myTransform));
 builder.build(new File("/tmp/persons.xml"));
 </pre>
 
 To find the title of all books that have more than three authors 
 and have 'Monterey' and 'Aquarium' somewhere in the title:
 <pre>
 String path = "/books/book";
 Map prefixes = new HashMap();
 prefixes.put("bib", "http://www.example.org/bookshelve/records");
 prefixes.put("xsd", "http://www.w3.org/2001/XMLSchema");

 StreamingTransform myTransform = new StreamingTransform() {
     private Nodes NONE = new Nodes(); 
 
     // execute XQuery against each element matching location path
     public Nodes transform(Element subtree) {
         Nodes results = XQueryUtil.xquery(subtree, 
            "title[matches(., 'Monterey') and matches(., 'Aquarium') and count(../author) > 3]");

         for (int i=0; i < results.size(); i++) {
             // do something useful with query results; here we just print them
             System.out.println(XOMUtil.toPrettyXML(results.get(i)));
         }
         return NONE; // current subtree becomes subject to garbage collection
         // returning empty node list removes current subtree from document being build.
         // returning new Nodes(subtree) retains the current subtree.
         // returning new Nodes(some other nodes) replaces the current subtree with
         // some other nodes.
         // if you want (SAX) parsing to terminate at this point, simply throw an exception 
     }
 };
 
 // parse document with a filtering Builder
 StreamingPathFilter filter = new StreamingPathFilter(path, prefixes);
 Builder builder = new Builder(filter.createNodeFactory(null, myTransform));
 Document doc = builder.build(new File("/tmp/books.xml"));
 System.out.println("doc.size()=" + doc.getRootElement().getChildElements().size());
 System.out.println(XOMUtil.toPrettyXML(doc));
 </pre>
 
 <p>
 Here is a similar snippet version that takes a filtering <code>Builder</code> from a 
 thread-safe pool with optimized parser configuration:
 <pre>
 ...
 ... same as above
 ...
 final StreamingPathFilter filter = new StreamingPathFilter(path, prefixes);
 BuilderPool pool = new BuilderPool(100, new BuilderFactory() {
     protected Builder newBuilder(XMLReader parser, boolean validate) {
         return new Builder(parser, validate, filter.createNodeFactory(null, myTransform));
     }
   }
 );

 Builder builder = pool.getBuilder(false);
 Document doc = builder.build(new File("/tmp/books.xml"));
 System.out.println("doc.size()=" + doc.getRootElement().getChildElements().size());
 </pre>
 
 <h4>Applicability</h4>
 
 This class is well suited for a P2P XML content messaging router, network
 transducer, transcoder, proxy or message queue that continuously 
 filters, transforms, routes and dispatches messages from infinitely long 
 streams.
 <p>
 However, this class is less suited for classic database oriented use cases.
 Here, scalability is limited as the input stream is sequentially scanned, without
 exploiting the indexing and random access properties typical for (relational) database
 environments. For such database oriented use cases, consider using the <a
 href="http://www.saxonica.com/documentation/documentation.html"> Saxon SQL
 extensions functions </a> to XQuery, or consider building your own mixed
 relational/XQuery integration layer, or consider using a database technology
 with native XQuery support.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../net/datenwerke/eximport/nuxlets/StreamingPathFilter.html#StreamingPathFilter-java.lang.String-java.util.Map-">StreamingPathFilter</a></span>(java.lang.String&nbsp;locationPath,
                   java.util.Map&nbsp;prefixes)</code>
<div class="block">Constructs a compiled filter from the given location path and prefix
 --&gt; namespaceURI map.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>NodeFactory</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../net/datenwerke/eximport/nuxlets/StreamingPathFilter.html#createNodeFactory-NodeFactory-net.datenwerke.eximport.nuxlets.StreamingTransform-">createNodeFactory</a></span>(NodeFactory&nbsp;childFactory,
                 <a href="../../../../net/datenwerke/eximport/nuxlets/StreamingTransform.html" title="interface in net.datenwerke.eximport.nuxlets">StreamingTransform</a>&nbsp;transform)</code>
<div class="block">Creates and returns a new node factory for this path filter, to be be passed
 to a <code>nu.xom.Builder</code>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="StreamingPathFilter-java.lang.String-java.util.Map-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>StreamingPathFilter</h4>
<pre>public&nbsp;StreamingPathFilter(java.lang.String&nbsp;locationPath,
                           java.util.Map&nbsp;prefixes)
                    throws <a href="../../../../net/datenwerke/eximport/nuxlets/StreamingPathFilterException.html" title="class in net.datenwerke.eximport.nuxlets">StreamingPathFilterException</a></pre>
<div class="block">Constructs a compiled filter from the given location path and prefix
 --&gt; namespaceURI map.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>locationPath</code> - the path expression to compile</dd>
<dd><code>prefixes</code> - a map of prefix --&gt; namespaceURI associations, each of type
            String --&gt; String.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../../net/datenwerke/eximport/nuxlets/StreamingPathFilterException.html" title="class in net.datenwerke.eximport.nuxlets">StreamingPathFilterException</a></code> - if the location path has a syntax error</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="createNodeFactory-NodeFactory-net.datenwerke.eximport.nuxlets.StreamingTransform-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createNodeFactory</h4>
<pre>public&nbsp;NodeFactory&nbsp;createNodeFactory(NodeFactory&nbsp;childFactory,
                                     <a href="../../../../net/datenwerke/eximport/nuxlets/StreamingTransform.html" title="interface in net.datenwerke.eximport.nuxlets">StreamingTransform</a>&nbsp;transform)</pre>
<div class="block">Creates and returns a new node factory for this path filter, to be be passed
 to a <code>nu.xom.Builder</code>.
 <p>
 Like a <code>Builder</code>, the node factory can be reused serially,
 but is not thread-safe because it is stateful. If you need thread-safety,
 call this method each time you need a new node factory for a new thread.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>childFactory</code> - an optional factory to delegate calls to. All calls except
            <code>makeRootElement()</code>,
            <code>startMakingElement()</code> and
            <code>finishMakingElement()</code> are delegated to the child
            factory. If this parameter is <code>null</code> it defaults 
            to the factory returned by
            <a href="../../../../net/datenwerke/eximport/nuxlets/XOMUtil.html#getIgnoreWhitespaceOnlyTextNodeFactory--"><code>XOMUtil.getIgnoreWhitespaceOnlyTextNodeFactory()</code></a>.</dd>
<dd><code>transform</code> - an application-specific callback called by the returned node
            factory whenever an element matches the filter's entire location
            path. May be <code>null</code> in which case the
            identity transformation is used, adding the matching element
            unchanged and "as is" to the document being build by a
            <code>nu.xom.Builder</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a node factory for this path filter</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/StreamingPathFilter.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../net/datenwerke/eximport/nuxlets/StreamingPathFilterException.html" title="class in net.datenwerke.eximport.nuxlets"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?net/datenwerke/eximport/nuxlets/StreamingPathFilter.html" target="_top">Frames</a></li>
<li><a href="StreamingPathFilter.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
